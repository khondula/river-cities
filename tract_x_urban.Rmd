---
title: "Tracts-Places-Lookup"
author: "Kelly Hondula"
date: "3/19/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(glue)
library(sf)
library(tibble)
library(sp)
library(rosm)
library(RStoolbox)
library(ggplot2)
library(readr)
```

54,858 census tracts in the NFIP data
```{r}
data_dir <- "/nfs/khondula-data/projects/river-cities/data"
claims_data_file <- glue::glue("{data_dir}/NFIP/openFEMA_claims20190831.csv")
claims_df <- vroom::vroom(claims_data_file)

claims_census_tracts <- claims_df$censustract %>% unique()
tracts_nchar <- purrr::map_int(claims_census_tracts, ~nchar(.x))
claims_tracts11 <- claims_census_tracts[which(tracts_nchar == 11)]
rm(claims_df, claims_census_tracts, tracts_nchar)
tibble::tibble(tract = claims_tracts11) %>%
  readr::write_csv(glue::glue("{data_dir}/claims_tracts11.csv"))
```

For each tract
- identify the state it is in (first two digits)
- 
```{r}
claims_tracts11 <- vroom::vroom(glue::glue("{data_dir}/claims_tracts11.csv"))
claims_tracts <- claims_tracts11[["tract"]]
claims_census_tract <- claims_tracts[2]
```

```{r}
get_tract_joins <- function(claims_census_tract){
  data_dir <- "/nfs/khondula-data/projects/river-cities/data"

  state_fips <- substr(claims_census_tract, 1, 2)
  # read in tracts spatial data and filter to tract
  tracts_dir <- "/nfs/public-data/census-tiger-2019/TRACT"
  tract_file <- glue::glue("{tracts_dir}/tl_2019_{state_fips}_tract.shp")
  tract_sf <- sf::st_read(tract_file) %>%
    dplyr::filter(GEOID == claims_census_tract)
  # read in urban areas spatial data for nation
  urban_dir <- "/nfs/public-data/census-tiger-2019/UAC/"
  urban_file <- glue::glue("{urban_dir}/tl_2019_us_uac10.shp")
  urban_sf <- sf::st_read(urban_file)
  # read in places spatial data for state
  places_dir <- "/nfs/public-data/census-tiger-2019/PLACES"
  place_file <- glue::glue("{places_dir}/tl_2019_{state_fips}_place.shp")
  place_sf <- sf::st_read(place_file)
  
  # find Place or Places that tract intersects with
  mat1 <- place_sf %>% sf::st_intersects(tract_sf, sparse = FALSE)
  place_wtract <- which(apply(mat1, 1, any))
  places_subset <- place_sf[place_wtract,]
  places_info <- places_subset %>% sf::st_drop_geometry()
  tract_x_place <- places_info %>%
    tibble::add_column(census_tract = claims_census_tract,
                       state = state_fips)
  filepath1 <- glue::glue("{data_dir}/census-lookups/tract-x-places/tract_{claims_census_tract}.csv")
  tract_x_place %>% readr::write_csv(filepath1)
  
  # find urban area that tract intersects with
  mat <- urban_sf %>% sf::st_intersects(tract_sf, sparse = FALSE)
  urban_wtract <- which(apply(mat, 1, any))
  urban_subset <- urban_sf[urban_wtract,]
  urban_info <- urban_subset %>% sf::st_drop_geometry()
  tract_x_urban <- urban_info %>%
    tibble::add_column(census_tract = claims_census_tract,
                       state = state_fips)
  filepath <- glue::glue("{data_dir}/census-lookups/tract-x-urban/tract_{claims_census_tract}.csv")
  tract_x_urban %>% readr::write_csv(filepath)
  
  # map
  my_area <- sf::st_union(urban_subset, places_subset)
    myextent <- sp::bbox(as(my_area, "Spatial"))
    osm1 <- osm.raster(myextent)
    
    urban_prj <- sf::st_transform(urban_subset, 3857)
    tract_prj <- sf::st_transform(tract_sf, 3857)
    places_prj <- sf::st_transform(places_subset, 3857)

    m1 <- ggRGB(osm1, ggObj = TRUE, r = 1, g = 2, b = 3)
    m2 <- m1 +
      geom_sf(data = urban_prj, 
              color = "purple",
              fill = "purple", 
              alpha = 0.25) +
      geom_sf(data = places_prj, 
              color = "orange",
              fill = "orange",
              alpha = 0.25) +
      geom_sf(data = tract_prj,
              color = "black",
              fill = NA,
              ) +
      theme_minimal() +
      ggtitle(glue::glue("{urban_subset$NAME10}\nTract {claims_census_tract}")) +
      xlab(element_blank()) +
      ylab(element_blank())
   
      mapfile <- glue::glue("{data_dir}/census-lookups/maps/tract_{claims_census_tract}.png")
      png(mapfile)
       print(m2)
      dev.off()
}

```

```{r}
get_tract_joins(claims_census_tract = claims_tracts[4])

claims_tracts[11:20] %>% 
  purrr::walk(~get_tract_joins(.x))
```

Run on cluster

```{r, eval = FALSE}
library(rslurm)
pars <- data.frame(claims_census_tract = claims_tracts,
                   stringsAsFactors = FALSE)

sjob <- slurm_apply(get_tract_joins, 
                    pars, 
                    jobname = 'tracts',
                    # slurm_options = list(partition = "sesync"),
                    nodes = 10, 
                    cpus_per_node = 4,
                    submit = TRUE)

rslurm::get_job_status(sjob)
# rslurm::cancel_slurm(sjob)
```

```{r, eval=FALSE}
glue::glue("{data_dir}/census-lookups/maps") %>%
  list.files() %>% 
  length()
```


For tracts that intersect multiple Places. potentially use the "reportedcity" 
column to agrep one of the places to use. Otherwise could add up the population
in both areas. 

```{r}
tract_sf %>% 
  leaflet() %>%
  setView(lng = st_coordinates(st_centroid(tract_sf))[1],
          lat = st_coordinates(st_centroid(tract_sf))[2], zoom = 10) %>%
  addTiles() %>%
  addPolygons(data = urban_subset, color = "red", popup = ~UACE10, group = "uac") %>%
  # addPolygons(data = place_sf_filter157, color = "red", popup = ~NAME, group = "places") %>%
  addPolygons(opacity = 1, group = "tract") %>%
  addLayersControl(overlayGroups = c("tract", "uac"))
```



